package webfx.tools.buildtool.modulefiles;

import org.w3c.dom.Node;
import webfx.tools.buildtool.ProjectModule;
import webfx.tools.util.reusablestream.ReusableStream;
import webfx.tools.buildtool.util.textfile.TextFileReaderWriter;
import webfx.tools.buildtool.util.xml.XmlUtil;

import java.nio.file.Path;
import java.util.Comparator;
import java.util.Scanner;

/**
 * @author Bruno Salmon
 */
public class GwtHtmlFile extends ModuleFile {

	private final static String TEMPLATE = "<!DOCTYPE html> <!-- Generated by WebFx -->\n" + "<html>\n" + "    <head>\n"
			+ "        <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n"
			+ "        <meta name=\"viewport\" content=\"user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1\" />\n"
			+ "${generatedHeadContent}" + "    </head>\n" + "    <body>\n" + "${generatedBodyContent}" + "    </body>\n"
			+ "</html>";

	public GwtHtmlFile(ProjectModule module) {
		super(module);
	}

	@Override
	Path getModulePath() {
		return getModule().getResourcesDirectory().resolve("public/index.html");
	}

	@Override
	void readFile() {
	}

	@Override
	public void writeFile() {
		StringBuilder headSb = new StringBuilder(), bodySb = new StringBuilder();
		ReusableStream<ProjectModule> transitiveProjectModules = ProjectModule
				.filterProjectModules(getModule().getThisAndTransitiveModules()).distinct();
		ReusableStream
				.concat(transitiveProjectModules.map(m -> m.getWebfxModuleFile().getHtmlNode()),
						ReusableStream.of(XmlUtil.lookupNode(
								XmlUtil.parseXmlString("<html><body order=\"0\"><script type=\"text/javascript\" src=\""
										+ getModule().getName().replaceAll("-", "_")
										+ ".nocache.js\" charset=\"utf-8\"/></body></html>"),
								"/html")))
				.filter(htmlNode -> checkNodeConditions(htmlNode, transitiveProjectModules))
				.flatMap(htmlNode -> htmlNode == null ? ReusableStream.empty()
						: XmlUtil.nodeListToReusableStream(htmlNode.getChildNodes(), n -> n))
				.stream().sorted(Comparator.comparingInt(GwtHtmlFile::getNodeOrder))
				.filter(headOrBodyNode -> checkNodeConditions(headOrBodyNode, transitiveProjectModules))
				.forEach(headOrBodyNode -> {
					String nodeName = headOrBodyNode.getNodeName();
					StringBuilder sb = "head".equalsIgnoreCase(nodeName) ? headSb
							: "body".equalsIgnoreCase(nodeName) ? bodySb : null;
					if (sb != null) {
						String xmlText = XmlUtil.formatHtmlText(headOrBodyNode);
						// Removing the head or body tag
						xmlText = xmlText.substring(xmlText.indexOf('>') + 1);
						xmlText = xmlText.substring(0, xmlText.length() - 3 - nodeName.length());
						xmlText = xmlText.replaceAll(
								"<META http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">", "");
						Scanner scanner = new Scanner(xmlText);
						boolean firstEmptyLineReached = false;
						int shift = 0, emptyLines = 0;
						while (scanner.hasNextLine()) {
							String line = scanner.nextLine();
							boolean blank = line.isBlank();
							if (!blank || firstEmptyLineReached) {
								if (!firstEmptyLineReached) {
									shift = 8 - line.indexOf("<");
									firstEmptyLineReached = true;
								} else if (blank) {
									emptyLines++;
									continue;
								} else {
									sb.append("\n".repeat(emptyLines));
									emptyLines = 0;
								}
								int firstChar = 0;
								if (shift >= 0)
									sb.append(" ".repeat(shift));
								else {
									firstChar = Math.min(-shift, line.length());
									for (int i = 0; i < firstChar; i++)
										if (!Character.isWhitespace(line.charAt(i))) {
											firstChar = i;
											break;
										}
								}
								sb.append(line.substring(firstChar)).append('\n');
							}
						}
					}
				});
		String text = TEMPLATE.replace("${generatedHeadContent}", headSb).replace("${generatedBodyContent}", bodySb);
		TextFileReaderWriter.writeTextFileIfNewOrModified(text, getModulePath());
	}

	private static boolean checkNodeConditions(Node headOrBodyNode,
			ReusableStream<ProjectModule> transitiveProjectModules) {
		String ifModulePropertyTrue = XmlUtil.getAttributeValue(headOrBodyNode, "if-module-property-true");
		if (ifModulePropertyTrue != null && transitiveProjectModules.noneMatch(
				m -> "true".equalsIgnoreCase(m.getWebfxModuleFile().getModuleProperty(ifModulePropertyTrue))))
			return false;
		String ifUsesJavaPackage = XmlUtil.getAttributeValue(headOrBodyNode, "if-uses-java-package");
		if (ifUsesJavaPackage != null
				&& !ProjectModule.modulesUsesJavaPackage(transitiveProjectModules, ifUsesJavaPackage))
			return false;
		String ifUsesJavaClass = XmlUtil.getAttributeValue(headOrBodyNode, "if-uses-java-class");
		if (ifUsesJavaClass != null && !ProjectModule.modulesUsesJavaClass(transitiveProjectModules, ifUsesJavaClass))
			return false;
		return true;
	}

	private static int getNodeOrder(Node node) {
		String order = XmlUtil.getAttributeValue(node, "order");
		return order == null ? 1 : Integer.parseInt(order);
	}
}
